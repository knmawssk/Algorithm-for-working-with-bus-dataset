# -*- coding: utf-8 -*-
"""Industrial practice

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DbtGSCQ-Bc1w2G0_67lIb-vV8-WG77uO
"""

pip install pandas folium openpyxl

import pandas as pd

route = pd.read_excel('/content/routes.xlsx', sheet_name= None)
stops = pd.read_excel('/content/bus-stops.xlsx')

stops.isna().sum()

for sheet_name, df in route.items():
    print(f"Missing values in sheet: {sheet_name}")
    print(df.isna().sum())
    print("-" * 20)

stops.dropna(inplace=True)

#ФИЛЬТРУЕМ И ПОКАЗЫВАЕМ ТОЛЬКО ОДИН МАРШРУТ

print("Доступные автобусы (листы):")
for name in route.keys():
    print(name)

bus_name = input("Введите название автобуса: ")

colors = {'forward': 'blue', 'backward': 'red'}

import folium

df = route[bus_name]

lat = df['latitude'].mean()
lon = df['longitude'].mean()
m = folium.Map(location=[lat, lon], zoom_start = 13)

if 'type' in df.columns:
    for type_, group in df.groupby('type'):
        points = group[['latitude', 'longitude']].values.tolist()
        folium.PolyLine(
            points,
            color=colors.get(type_),
            weight=3,
            opacity=0.7,
            tooltip=f'{bus_name} ({type_})'
        ).add_to(m)

from geopy.distance import geodesic
import pandas as pd
import folium


def is_near_route(stop_point, route_points, max_distance=0.2):
    for route_point in route_points:
        if -90 <= stop_point[0] <= 90 and -180 <= stop_point[1] <= 180 and \
           -90 <= route_point[0] <= 90 and -180 <= route_point[1] <= 180:
            if geodesic(stop_point, route_point).km < max_distance:
                return True
        else:

            print(f"Warning: Invalid coordinates found - Stop: {stop_point}, Route Point: {route_point}")
    return False

stops_filtered = stops[(stops['latitude'].between(-90, 90)) & (stops['longitude'].between(-180, 180))].copy()

route_points = df[['latitude', 'longitude']].values.tolist()

route_points_filtered = [p for p in route_points if -90 <= p[0] <= 90 and -180 <= p[1] <= 180]

nearby_stops = stops_filtered[stops_filtered.apply(lambda row: is_near_route((row['latitude'], row['longitude']), route_points_filtered), axis=1)]

for _, stop in nearby_stops.iterrows():
    folium.Marker(
        location=[stop['latitude'], stop['longitude']],
        popup=stop['bus_stop_name'],
        icon=folium.Icon(color='red', icon='bus')
    ).add_to(m)

m

#ЗАДАНИЕ2

import pandas as pd
import numpy as np
import folium
from math import radians, cos, sin, asin, sqrt


def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1)*cos(lat2)*sin(dlon/2)**2
    c = 2*asin(sqrt(a))
    return R * c


route_data = pd.read_excel('/content/routes.xlsx', sheet_name=None)
stops = pd.read_excel('/content/bus-stops.xlsx')
stops.dropna(inplace=True)

results = []

for bus_name, df in route_data.items():
    row = {'route_id': bus_name}

    for direction in ['forward', 'backward']:
        if direction in df['type'].unique():
            df_dir = df[df['type'] == direction]
            df_dir = df_dir.reset_index(drop=True)

            dist = 0
            for i in range(len(df_dir) - 1):
                lat1, lon1 = df_dir.loc[i, ['latitude', 'longitude']]
                lat2, lon2 = df_dir.loc[i+1, ['latitude', 'longitude']]
                dist += haversine(lat1, lon1, lat2, lon2)

            row[f'distance_{direction}'] = round(dist, 2)
        else:
            row[f'distance_{direction}'] = 0.0

    row['full_length'] = round(row['distance_forward'] + row['distance_backward'], 2)
    results.append(row)

# Формируем итоговую таблицу
summary_df = pd.DataFrame(results)

# Классификация по длине маршрута
def classify(length):
    if length < 10:
        return 'менее 10 км'
    elif 10 <= length < 25:
        return 'от 10 до 25 км'
    elif 25 <= length < 35:
        return 'от 25 до 35 км'
    elif 35 <= length < 50:
        return 'от 35 до 50 км'
    else:
        return 'более 50 км'

summary_df['category'] = summary_df['full_length'].apply(classify)

# Группировка по категориям
grouped = summary_df.groupby('category').agg({
    'route_id': list,
    'full_length': 'count'
}).rename(columns={'route_id': 'routes', 'full_length': 'count'}).reset_index()

summary_df.to_excel('/content/задание2.xlsx', index=False)

grouped.to_excel('/content/задание2_grouped.xlsx', index=False)

#ЗАДАНИЕ3

# Загружаем таблицу остановок
stops = pd.read_excel('/content/bus-stops.xlsx')
stops.dropna(inplace=True)

# Filter out stops with invalid latitude or longitude
stops_filtered = stops[(stops['latitude'].between(-90, 90)) & (stops['longitude'].between(-180, 180))].copy()

# Функция: найти ближайшую остановку по координате
def find_nearest_stop(lat, lon, stops_df):
    point = (lat, lon)
    stops_df['distance'] = stops_df.apply(
        lambda row: geodesic(point, (row['latitude'], row['longitude'])).meters,
        axis=1
    )
    return stops_df.sort_values('distance').iloc[0]['bus_stop_name']

# Загрузка маршрутов (assuming this is needed again, otherwise use the one from the previous cell)
routes = pd.read_excel('/content/routes.xlsx', sheet_name=None)

# Initialize a list to store results for start and end stops
route_stop_names = []

for route_name, df in routes.items():
    # Убедимся, что данные отсортированы по порядку
    if 'type' not in df.columns or 'latitude' not in df.columns or 'longitude' not in df.columns:
        continue

    for direction in ['forward', 'backward']:
        route_df = df[df['type'] == direction].reset_index(drop=True)

        if len(route_df) < 2:
            continue

        start_lat, start_lon = route_df.iloc[0]['latitude'], route_df.iloc[0]['longitude']
        end_lat, end_lon = route_df.iloc[-1]['latitude'], route_df.iloc[-1]['longitude']

        if -90 <= start_lat <= 90 and -180 <= start_lon <= 180:
             start_name = find_nearest_stop(start_lat, start_lon, stops_filtered.copy()) # Pass a copy to avoid modifying original stops_filtered
        else:
             start_name = "Invalid Coordinates"
             print(f"Warning: Invalid start coordinates for route {route_name} ({direction})")


        if -90 <= end_lat <= 90 and -180 <= end_lon <= 180:
            end_name = find_nearest_stop(end_lat, end_lon, stops_filtered.copy()) # Pass a copy
        else:
            end_name = "Invalid Coordinates"
            print(f"Warning: Invalid end coordinates for route {route_name} ({direction})")

        route_stop_names.append({
            'Маршрут': route_name,
            'Направление': direction,
            'Начальная остановка (поиск)': start_name,
            'Конечная остановка (поиск)': end_name
        })
route_stop_names_df = pd.DataFrame(route_stop_names)

print(route_stop_names_df)

# Загрузка маршрутов
routes = pd.read_excel('/content/routes.xlsx', sheet_name=None)

results = []

for route_name, df in routes.items():
    # Убедимся, что данные отсортированы по порядку
    if 'type' not in df.columns or 'latitude' not in df.columns or 'longitude' not in df.columns:
        continue

    for direction in ['forward', 'backward']:
        route_df = df[df['type'] == direction].reset_index(drop=True)

        if len(route_df) < 2:
            continue

        # Расчёт расстояний между последовательными точками
        distances = []
        for i in range(len(route_df) - 1):
            point1 = (route_df.loc[i, 'latitude'], route_df.loc[i, 'longitude'])
            point2 = (route_df.loc[i + 1, 'latitude'], route_df.loc[i + 1, 'longitude'])
            distance = geodesic(point1, point2).km  # в километрах
            distances.append(distance)

        # Общая длина маршрута
        total_length_km = sum(distances)
        avg_distance_m = np.mean(distances) * 1000  # в метрах
        median_distance_m = np.median(distances) * 1000  # в метрах

        start_point = f"{round(route_df.iloc[0]['latitude'], 5)}, {round(route_df.iloc[0]['longitude'], 5)}"
        end_point = f"{round(route_df.iloc[-1]['latitude'], 5)}, {round(route_df.iloc[-1]['longitude'], 5)}"

        results.append({
            'Маршрут': route_name,
            'Направление': direction,
            'Начальная остановка': start_point,
            'Конечная остановка': end_point,
            'Длина оборота (км)': round(total_length_km, 3),
            'Среднее расстояние между остановками (м)': round(avg_distance_m, 1),
            'Медианное расстояние между остановками (м)': round(median_distance_m, 1)
        })

# Преобразуем в DataFrame
res_df = pd.DataFrame(results)

# Разделим данные на forward и backward, чтобы собрать итоговую таблицу
forward_df = res_df[res_df['Направление'] == 'forward'].set_index('Маршрут')
backward_df = res_df[res_df['Направление'] == 'backward'].set_index('Маршрут')

# Объединение данных
final_df = forward_df[['Начальная остановка', 'Конечная остановка', 'Длина оборота (км)',
                       'Среднее расстояние между остановками (м)',
                       'Медианное расстояние между остановками (м)']].rename(columns={
    'Среднее расстояние между остановками (м)': 'Среднее расстояние (прямое) (м)',
    'Медианное расстояние между остановками (м)': 'Медианное расстояние (прямое) (м)',
    'Длина оборота (км)': 'Длина оборота (км.)'
})

final_df['Среднее расстояние (обратное) (м)'] = backward_df['Среднее расстояние между остановками (м)']
final_df['Медианное расстояние (обратное) (м)'] = backward_df['Медианное расстояние между остановками (м)']
final_df.reset_index(inplace=True)

# Категоризация по медианному расстоянию прямого направления
def categorize_distance(median):
    if pd.isna(median):
        return 'Нет данных'
    elif median <= 300:
        return 'до 300 м'
    elif 300 < median <= 500:
        return 'от 300 м до 500 м'
    else:
        return 'больше 500 м'

final_df['Категория (по медиане, прямое)'] = final_df['Медианное расстояние (прямое) (м)'].apply(categorize_distance)

final_df.to_excel('/content/задание3.xlsx', index=False)

#ЗАДАНИЕ4

matched_data = []

stops_filtered = stops[(stops['latitude'].between(-90, 90)) & (stops['longitude'].between(-180, 180))].copy()


for route_name, df in route.items():
    if 'latitude' not in df.columns or 'longitude' not in df.columns:
        continue

    df_filtered = df[(df['latitude'].between(-90, 90)) & (df['longitude'].between(-180, 180))].copy()

    points = df_filtered[['latitude', 'longitude']].values.tolist()

    if not points:
        print(f"Warning: No valid coordinate points found for route {route_name}. Skipping.")
        continue


    for _, stop in stops_filtered.iterrows():
        stop_coord = (stop['latitude'], stop['longitude'])

        # Проверим, есть ли хотя бы одна точка маршрута в пределах 200 м
        if any(geodesic(stop_coord, p).meters < 200 for p in points):
            matched_data.append({
                'route_id': route_name,
                'bus_stop_name': stop['bus_stop_name']
            })

# Создаем DataFrame
route_stops_df = pd.DataFrame(matched_data).drop_duplicates()

stop_routes_df.sort_values('Количество маршрутов', ascending=False, inplace=True)
stop_routes_df.to_excel('/content/пересадочные_узлы.xlsx', index=False)

route_stops_df = pd.read_excel('/content/задание4.xlsx')

#ЗАДАНИЕ 5

# Группируем
stop_routes_df = route_stops_df.groupby('bus_stop_name')['route_id'].agg(
    routes=lambda x: sorted(set(x)),
    count=lambda x: len(set(x))
).reset_index()

# Переименовываем колонки
stop_routes_df.columns = ['Остановка', 'Маршруты', 'Количество маршрутов']

threshold = stop_routes_df['Количество маршрутов'].median()

stop_routes_df['Пересадочный узел'] = stop_routes_df['Количество маршрутов'] >= threshold

stop_routes_df.sort_values('Количество маршрутов', ascending=False, inplace=True)
stop_routes_df.to_excel('/content/пересадочные_узлы.xlsx', index=False)

#ЗАДАНИЕ 6

import pandas as pd
import numpy as np
from geopy.distance import geodesic
import math

# Расстояние между двумя точками в метрах
def distance_m(p1, p2):
    return geodesic(p1, p2).meters

# Вычисление угла между тремя последовательными точками
def compute_angle(p1, p2, p3):
    a = np.array(p1)
    b = np.array(p2)
    c = np.array(p3)

    ba = a - b
    bc = c - b

    # угол в градусах между векторами
    cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
    cosine_angle = np.clip(cosine_angle, -1, 1)  # на случай округления
    angle_rad = np.arccos(cosine_angle)
    return np.degrees(angle_rad)

routes = pd.read_excel('/content/routes.xlsx', sheet_name=None)

results = []

for route_id, df in route.items():
    for direction in ['forward', 'backward']:
        route_df = df[df['type'] == direction].reset_index(drop=True)

        if len(route_df) < 5:
            continue

        coords = route_df[['latitude', 'longitude']].values.tolist()

        #Проверка на кольцевой маршрут
        start = coords[0]
        end = coords[-1]
        loop_distance = distance_m(start, end)

        is_loop = loop_distance < 500  # менее 500 м

        # Подсчёт резких углов
        sharp_turns = 0
        for i in range(1, len(coords) - 1):
            angle = compute_angle(coords[i - 1], coords[i], coords[i + 1])
            if angle < 90:
                sharp_turns += 1

        if is_loop:
            route_type = "Кольцевой"
            reason = f"Начало и конец маршрута находятся в {int(loop_distance)} м друг от друга."
        elif sharp_turns >= 5:  # Можно настраивать порог
            route_type = "Зигзагообразный"
            reason = f"Маршрут содержит {sharp_turns} резких поворотов (>90°)."
        else:
            route_type = "Линейный"
            reason = f"Низкое количество резких поворотов ({sharp_turns}), маршрут не кольцевой."

        results.append({
            'Маршрут': route_id,
            'Направление': direction,
            'Тип маршрута': route_type,
            'Комментарий': reason
        })

final_df = pd.DataFrame(results)
final_df.to_excel('/content/кольцевой или нет.xlsx', index=False)